<pre>
  BIP: 114
  Layer: Consensus (soft fork)
  Title: Merklized Script
  Author: Johnson Lau <jl2012@xbt.hk>
  Comments-Summary: No comments yet.
  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0114
  Status: Draft
  Type: Standards Track
  Created: 2016-04-02
  License: BSD-3-Clause
           CC0-1.0
</pre>

==Abstract==
This BIP defines a new witness program type that uses a Merkle tree to encode mutually exclusive branches in a script. This enables complicated redemption conditions that are currently not possible, improves privacy by hiding unexecuted scripts, and allows inclusion of non-consensus enforced data with very low or no additional cost.

==Motivation==
===Evolution of Bitcoin script system===
Bitcoin uses a script system to specify the conditions for redemption of transaction outputs. In its original design, the conditions for redemption are directly recorded in the scriptPubKey by the sender of the funds. This model has several drawbacks, particularly for complicated scripts:
# It could be difficult for the receiver to specify the conditions;
# Large scripts take up more UTXO space;
# The sender will pay for the additional block space;
# To prevent DoS attack, scripts are limited to 10,000 bytes and 201 op codes;
# Any unexecuted branches and non-consensus enforced data in the script are visible to the public, consuming block space while damaging privacy.

The [[bip-0016.mediawiki|BIP16]] (Pay-to-script-hash, "P2SH") fixes the first 3 problems by using a fixed-length 20-byte script hash in the scriptPubKey, and moving the responsibility for supplying the script to the redeemer. However, due to the data push size limit in script, a P2SH script may not be bigger than 520 bytes. Also, P2SH still requires the redeemer to publish all unexecuted branches of the script.

The [[bip-0141.mediawiki|BIP141]] defines 2 new types of scripts that support segregated witness. The pay-to-witness-script-hash (P2WSH) is similar to P2SH is many ways. By supplying the script in witness, P2WSH restores the original 10,000 byte script limit. However, it still requires publishing of unexecuted branches.

The idea of Merkelized Abstract Syntax Tree (MAST) is to use a Merkle tree to encode the operations in a script. When spending, users may provide only the branches they are executing, and hashes that connect the branches to the fixed size Merkle root. This reduces the size of redemption stack from O(n) to O(log n) (n as the number of operations). This enables complicated redemption conditions that is currently not possible due to the script size and opcode limit, improves privacy by hiding unexecuted branches, and allows inclusion of non-consensus enforced data with very low or no additional cost.

This proposal is a simplified and special case MAST. Instead of encoding individual operations, the Merkle root encodes mutually exclusive conditional script branches. Although this is not a full implementation of MAST, it provides the same level of privacy and O(log n) scalability.

===Additional scripts in witness===
In Bitcoin's original design, users are allowed to include functional script (i.e. not just data push) in <code>scriptSig</code>. However, since there is no mechanism for the key holder to sign the script, this design brings no functionality but is instead a source of malleability (BIP62). When segregated witness is introduced with BIP141, it is also not possible to include additional scripts in the witness.

However, with a proper design, allowing additional scripts in transaction inputs could allow features not possible with the existing system. For example, key holder(s) may delegate the right of spending to other keys, with or without additional conditions such as locktime. It may also be used with other proposed functions, such as checking the block hash, which might not be known when the output was created.

This proposal defines a mechanism to allow such kind of additional scripts as part of witness. It is further defined in BIPYYY to make sure such scripts are not third party malleable.

==Specification==
===Merklized Script===
In [[bip-0141.mediawiki|BIP141]], witness programs with a version byte of 1 or larger are considered to be anyone-can-spend scripts. The following new validation rules are applied if the witness program version byte is 1 and the program size is 32 bytes. The witness program is the <code>Script Merkle Root</code> (defined hereinafter).

To redeem an output of this kind, the witness MUST consist at least 3 items.

<code>Key Code</code> is the last witness item. It MUST NOT be smaller than 33 bytes, while there is no upper limit. <code>Key Code Hash</code> is the single SHA256 value of a <code>Key Code</code>

<code>Path</code> is the second last witness item. It is a serialized Merkle path of the <code>Key Code Hash</code>. Size of <code>Path</code> MUST be a multiple of 32 bytes, and MUST NOT be bigger than 1024 bytes. Each 32 byte word is a double-SHA256 Merkle node (or single-SHA256 if it is the hash of another <code>Key Code Hash</code>) in the Merkle branch connecting to the <code>Script Merkle Root</code>. <code>Depth</code> of the tree (0 to 32) is the size of <code>Path</code> divided by 32.

<code>Position</code> is the third last witness item. It indicates the location of the <code>Key Code Hash</code> in the Merkle tree, with 0 indicating the leftmost position. It is a signed <code>CScriptNum</code> integer. <code>Position</code> MUST be minimally encoded as described in BIP62, non-negative, and MUST NOT be larger than the maximum number of items allowed by the <code>Depth</code> of the tree. For example, if <code>Depth</code> is 4, the valid range of <code>Position</code> is 0 to 15 (2<sup>4</sup>-1).

<code>Script Merkle Root</code> is the Merkle root calculated by the <code>ComputeMerkleRootFromBranch</code> function, using <code>Key Code Hash</code>, <code>Path</code> and <code>Position</code>.

The script evaluation fails if <code>Script Merkle Root</code> does not match the witness program.

====Merklized Script Version 0====
If the first byte of <code>Key Code</code> is 0, it is interpreted as Merklized Script Version 0 (<code>MSV0</code>) and is further processed.

<code>Key Code Hash</code>, <code>Path</code>, and <code>Position</code> are removed from the witness stack. The remaining stack MUST have at least 1 item, or the evaluation fails.

The last witness stake item is <code>nScriptWitCode</code> which MUST be a minimally encoded value for 0 to 5, or the evaluation fails.

Excluding the <code>nScriptWitCode</code> item, the number of remaining stake items MUST NOT be less than the value <code>nScriptWitCode</code>, or the evaluation fails.

If <code>nScriptWitCode</code> is not 0, the witness item before <code>nScriptWitCode</code> is <code>scriptWitCode0</code>, and the item before <code>scriptWitCode0</code> is <code>scriptWitCode1</code>, etc. Size of the highest index <code>scriptWitCode</code> MUST NOT be 0 (in such case, a smaller <code>nScriptWitCode</code> value should be used, and omit the 0 size <code>scriptWitCode</code>).

Unused stack items, if any, are treated as <code>Input Stack</code> for script evaluation.

<code>scriptWitCode</code>, if any, are evaluated one by one, starting from the one with highest index. <code>scriptKeyCode</code> is <code>Key Code</code> with the leading 0 version byte removed. <code>scriptKeyCode</code> is evaluated after all <code>scriptWitCode</code>.

Similar to the evaluation of legacy <code>scriptSig</code> and <code>scriptPubKey</code>:
* The outcome stack of a script is inherited by the next script
* Altstack is reset to empty between two scripts
* Conditional operations (<code>OP_IF</code>, <code>OP_NOTIF</code>, <code>OP_ELSE</code>, and <code>OP_ENDIF</code>) MUST be balanced within each script individually
* All <code>scriptWitCode</code> and <code>scriptKeyCode</code> MUST NOT fail

Similar to the evaluation of version 0 witness script:
* Size of any <code>Input Stack</code> item MUST NOT be larger than 520 bytes
* The final stack MUST contain exactly one <code>TRUE</code> item
* The total number of stack and altstack items MUST NOT be higher than 1000 after execution of any <code>Opcode</code>

The evaluation MUST also fail with one of the following conditions:
* The total size of all <code>scriptWitCode</code> and <code>scriptKeyCode</code> (without leading 0 version byte) is larger than 10,000 bytes
* The total number of non-push operations (<code>nOpCount</code>) of all <code>scriptWitCode</code> and <code>scriptKeyCode</code> is more than 201. Each <code>Opcode</code> with value of or above <code>0x61</code>, except <code>OP_CHECKMULTISIG</code> and <code>OP_CHECKMULTISIGVERIFY</code>, is counted as 1 <code>nOpCount</code>. For m-of-n <code>OP_CHECKMULTISIG</code> and <code>OP_CHECKMULTISIGVERIFY</code>, they are counted as m+1 <code>nOpCount</code>. <ref>In legacy, <code>P2SH</code> and <code>P2WSH</code> scripts, m-of-n <code>OP_CHECKMULTISIG</code> and <code>OP_CHECKMULTISIGVERIFY</code> are counted as n+1 <code>nOpCount</code></code></ref>


===New script features in MSV0===
New script features are introduced in <code>MSV0</code>, described in different BIPs.

BIPVVV describes pay-to-witness-public-key (<code>P2WPK</code>), a more efficient way to use all the functions of <code>MSV0</code> if the only condition to spend an output is signature from a single public key.

BIPWWW describes the re-enabling and re-defining of disabled string and bitwise operations, including <code>OP_CAT</code>, <code>OP_LEFT</code>, <code>OP_RIGHT</code>, <code>OP_SUBSTR</code>, <code>OP_INVERT</code>, <code>OP_AND</code>, <code>OP_OR</code>, <code>OP_XOR</code>, <code>OP_RSHIFT</code>, and <code>OP_LSHIFT</code>.

BIPXXX describes the re-enabling and re-defining of disabled numeric operations, including <code>OP_2MUL</code>, <code>OP_MUL</code>, <code>OP_2DIV</code>, <code>OP_DIV</code>, <code>OP_MOD</code>, and re-defining of existing numeric operations, including <code>OP_CHECKLOCKTIMEVERIFY</code>, <code>OP_CHECKSEQUENCEVERIFY</code>, <code>OP_1ADD</code>, <code>OP_1SUB</code>, <code>OP_NEGATE</code>, <code>OP_ABS</code>, <code>OP_NOT</code>, <code>OP_0NOTEQUAL</code>, <code>OP_ADD</code>, <code>OP_SUB</code>, <code>OP_BOOLAND</code>, <code>OP_BOOLOR</code>, <code>OP_NUMEQUAL</code>, <code>OP_NUMEQUALVERIFY</code>, <code>OP_NUMNOTEQUAL</code>, <code>OP_LESSTHAN</code>, <code>OP_GREATERTHAN</code>, <code>OP_LESSTHANOREQUAL</code>, <code>OP_GREATERTHANOREQUAL</code>, <code>OP_MIN</code>, <code>OP_MAX</code>, and <code>OP_WITHIN</code>.

BIPYYY describes the re-defining of <code>OP_CHECKSIG</code>, <code>OP_CHECKSIGVERIFY</code>, <code>OP_CHECKMULTISIG</code>, and <code>OP_CHECKMULTISIGVERIFY</code>, and the introduction of the new <code>OP_CHECKSIGFROMSTACKVERIFY</code>.

BIPZZZ describes the introduction of the new <code>OP_PUSHTXDATA</code>.

===Upgradability===
If witness program version byte is 1 but the program size is neither 32 nor 33 bytes, the script returns a success without further evaluation. 

For Merklized Script, if the <code>Script Merkle Root</code> is matched but the first byte of <code>Key Code</code> is not 0, the script returns a success without further evaluation.

<code>SigOpsCost</code> is counted as 0 in these cases.

== Rationale ==
'''Minimum 33-byte size requirement and use of single-SHA256 for <code>Key Code</code>:''' If double-SHA256 is used to hash both <code>Key Code</code> and the 64-byte concatenated Merkle hashes, an output might be stolen if any of the concatenated hashes is a valid <code>Key Code</code>. On the other hand, if single-SHA256 is used for <code>Key Code</code> while double-SHA256 is used for concatenated Merkle hashes, an output might be stolen if the single-SHA256 of any concatenated hashes is a valid <code>Key Code</code>. It is suffice to avoid the latter case by rejecting any <code>Key Code</code> with 32 bytes. However, as the compressed public key size is 33 bytes, it is obvious that any <code>Key Code</code> below 33 bytes are either invalid or anyone-can-spend<ref>Except trying to do 160-bit <code>P2PKH</code> inside <code>MSV0</code>. But this is just a waste of space since the complete public key is still needed in the input stack</ref>. As a result, there is no loss in functions to reject any <code>Key Code</code> smaller than 33 bytes.

'''Marking the Merklized Script version at the beginning of <code>Key Code</code>:''' Merklized Script version could be marked in either <code>scriptPubKey</code> or <code>witness</code>, but <code>witness</code> takes less block space. Also, marking in <code>Key Code</code> means we may mix scripts of different versions in an output, which could improve privacy if the use of special script versions is hidden.

'''<code>scriptWitCode</code> design:''' The <code>scriptWitCode</code> design allows key holder(s) of an output to include additional scripts. It is further described in BIPYYY.

== Examples ==
=== Calculation of Script Merkle Root ===

(to be completed)


=== Imbalance MS ===
When constructing a MS, if the user believes that some of the branches are more likely to be executed, they may put them closer to the <code>Script Merkle Root</code>. It will save some witness space when the preferred branches are actually executed. For example, in payment channel constructions, "cooperative" scripts are more likely to be executed than "uncooperative" ones.

=== Escrow with Timeout ===
The following is the "Escrow with Timeout" example in [[bip-0112.mediawiki|BIP112]]:
    IF
        2 <Alice's pubkey> <Bob's pubkey> <Escrow's pubkey> 3 CHECKMULTISIG
    ELSE
        "30d" CHECKSEQUENCEVERIFY DROP
        <Alice's pubkey> CHECKSIG
    ENDIF

Using compressed public key, the size of this script is 150 bytes.

With MSV0, this script could be broken down into 2 mutually exclusive branches:<ref>In BIPXXX, it is proposed that OP_CHECKLOCKTIMEVERIFY and OP_CHECKSEQUENCEVERIFY will pop the top stack item</ref>
    2 <Alice's pubkey> <Bob's pubkey> <Escrow's pubkey> 3 CHECKMULTISIG (105 bytes)
    "30d" CHECKSEQUENCEVERIFY <Alice's pubkey> CHECKSIG (42 bytes)

Since only one branch will be published, it is more difficult for a blockchain analyst to determine the details of the escrow.

=== Hashed Time-Lock Contract ===
The following is the "Hashed Time-Lock Contract" example in [[bip-0112.mediawiki|BIP112]]:
    HASH160 DUP <R-HASH> EQUAL
    IF
        "24h" CHECKSEQUENCEVERIFY
        2DROP
        <Alice's pubkey>
    ELSE
        <Commit-Revocation-Hash> EQUAL
        NOTIF
            "Timestamp" CHECKLOCKTIMEVERIFY DROP
        ENDIF
        <Bob's pubkey>
    ENDIF
    CHECKSIG

With MSV0, it is flattened to 3 mutually exclusive branches:
    HASH160 <R-HASH> EQUALVERIFY "24h" CHECKSEQUENCEVERIFY <Alice's pubkey> CHECKSIG
    HASH160 <Commit-Revocation-Hash> EQUALVERIFY <Bob's pubkey> CHECKSIG
    "Timestamp" CHECKLOCKTIMEVERIFY <Bob's pubkey> CHECKSIG

which significantly improves readability and reduces the witness size when it is redeemed.

=== Large multi-signature constructs ===
The current <code>OP_CHECKMULTISIG</code> supports up to 20 public keys. Although it is possible to extend it beyond 20 keys by using multiple CHECKSIGs, the construction could be very complicated and soon use up the 10,000 bytes and 201 <code>nOpCount</code> limit.

With MSV0, large and complex multi-signature constructs could be flattened to many simple <code>OP_CHECKMULTISIG</code> conditions. For example, a 3-of-2000 multi-signature scheme could be expressed as 1,331,334,000 3-of-3 <code>OP_CHECKMULTISIG</code>, which forms a 31-level MS. The scriptPubKey still maintains a fixed size of 34 bytes, and the redemption witness will be very compact, with less than 1,500 bytes.

=== Commitment of extra data ===
Currently, committing extra data in the scriptPubKey requires the use of <code>OP_RETURN</code> which occupies additional block space. With MS, users may commit such data as a branch. Depends on the number of executable branches, inclusion of such a commitment may incur no extra witness space, or 32 bytes at most.

An useful case would be specifying "message-signing keys", which are not valid for spending, but allow users to sign any message without touching the cold storage "funding key".

== Backward compatibility ==
As a soft fork, older software will continue to operate without modification. Non-upgraded nodes, however, will consider Merklized Script and <code>P2WPKV0</code> programs as anyone-can-spend scripts. Wallets should always be wary of anyone-can-spend scripts and treat them with suspicion.

== Deployment ==
Exact details TBD.

== Credits ==
Merklized script is based on the idea of Merklized Abstract Syntax Tree, which originates from Russell O’Connor, Pieter Wuille, and [https://bitcointalk.org/index.php?topic=255145.msg2757327#msg2757327 Peter Todd].

== Reference Implementation ==
https://github.com/jl2012/bitcoin/commits/vault

== References ==
*[[bip-0141.mediawiki|BIP141 Segregated Witness (Consensus layer)]]

== Copyright ==
This document is dual licensed as BSD 3-clause, and Creative Commons CC0 1.0 Universal.
