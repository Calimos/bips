<pre>
  BIP: ?
  Title: Scripting System in Merkelized Abstract Syntax Tree
  Author: Johnson Lau <jl2012@xbt.hk>
  Status: Draft
  Type: Standards Track
  Created: 2016-04-20
</pre>

==Abstract==
This BIP defines the scripting system in Merkelized Abstract Syntax Tree (BIP114). It re-enables some of the previously disabled opcodes, introduces new opcodes, and defines expandable opcodes for future extension.

==Motivation==
Bitcoin uses a script system to specify the conditions for redemption of transaction outputs. It is composed of 186 opcodes, each represented by an one-byte unsigned integer from 0x00 to 0xb9. Since the first release of Bitcoin in 2009, 19 opcodes including  <code>VER</code>, <code>VERIF</code>, <code>VERNOTIF</code>,<code>RETURN</code>,  <code>CAT</code>, <code>SUBSTR</code>, <code>LEFT</code>, <code>RIGHT</code>, <code>INVERT</code>, <code>AND</code>, <code>OR</code>, <code>XOR</code>, <code>2MUL</code>, <code>2DIV</code>, <code>MUL</code>, <code>DIV</code>, <code>MOD</code>, <code>LSHIFT</code>, and <code>RSHIFT</code>, were disabled due to security reasons. Executing a disabled opcode will terminate the script evaluation immediately and return a failure.

Some of the disabled opcodes could be useful, but unfortunately it is impossible to re-enable these in the original scripting system with a softfork. It is also not possible to introduce new stack-manipulating opcodes to the original system with a softfork. For example, new opcodes including CHECKLOCKTIMEVERIFY (BIP65) and CHECKSEQUENCEVERIFY (BIP112) could either return a failure immediately, or do nothing.

Under the witness program version byte system, it is possible to introduce completely novel scripting system with a softfork. The new semantics will be confined to a particular version of witness program without affecting any existing scripting system. As part of Merkelized Abstract Syntax Tree (BIP114) softfork, this BIP will:

#re-enable <code>CAT</code>, <code>SUBSTR</code>, <code>LEFT</code>, <code>RIGHT</code>, <code>INVERT</code>, <code>AND</code>, <code>OR</code>, <code>XOR</code>, <code>LSHIFT</code>, and <code>RSHIFT</code>;
#introduce new opcodes: <code>DUPTOALTSTACK</code>, <code>DUPFROMALTSTACK</code>, <code>SWAPSTACK</code>, <code>SWAPCAT</code>, and <code>RESIZE</code>;
#defines expandable opcodes for future softforks of stack manipulating opcodes: <code>EXPAND1</code> to <code>EXPAND32</code>.


==Specification==
In the following, x<sub>n</sub> represents the top-n item on the stack. For example, x<sub>1</sub> is the top stack item, and x<sub>2</sub> is the second-to-top item.

<code>CAT</code> (0x7e) and <code>SWAPCAT</code> (0xbd) will remove the top two stack items and push the concantenated string onto the stack. If x<sub>2</sub> is "abcd" and x<sub>1</sub> is "efgh", <code>CAT</code> will return "abcdefgh" while <code>SWAPCAT</code> will return "efghabcd". The script will fail if the stack has less than two items or the total size of the concantenated string is bigger than TBD bytes.

<code>SUBSTR</code> will remove the top three stack items and push a substring of x<sub>3</sub> onto the stack, with x<sub>2</sub> as the starting position, and x<sub>1</sub> as the length of the substring. For example, if x<sub>3</sub> is "abcdefghij", x<sub>2</sub> is 3 and x<sub>3</sub> is 4, the returned string is "defg". The script will fail if the stack has less then three items, x<sub>2</sub> or x<sub>3</sub> is negative, x<sub>2</sub> is not smaller than the size of x<sub>1</sub>, and x<sub>2</sub> + x<sub>3</sub> is bigger than the size of x<sub>1</sub>.

<code>LEFT</code> will remove the top two stack items and push the x<sub>1</sub> leftmost characters of x<sub>2</sub> onto the stack. For example, if x<sub>2</sub> is "abcdefghij", x<sub>1</sub> is 6, the returned string is "abcdef". A null is returned if x<sub>1</sub> is 0, and x<sub>2</sub> is returned if x<sub>1</sub> is not smaller than the size of x<sub>2</sub>. The script will fail if the stack has less than two items or x<sub>1</sub> is negative.

<code>RIGHT</code> will remove the top two stack items and push the x<sub>1</sub> rightmost characters of x<sub>2</sub> onto the stack. For example, if x<sub>2</sub> is "abcdefghij", x<sub>1</sub> is 6, the returned string is "efghij". x<sub>2</sub> is returned if x<sub>1</sub> is 0, and a null is returned if x<sub>1</sub> is not smaller than the size of x<sub>2</sub>. The script will fail if the stack has less than two items or x<sub>1</sub> is negative.

<code>INVERT</code> will flip the bits of the top stack item. For example, 0xbeef (0b1011111011101111) will become 0x4110 (0b0100000100010000). The script will fail if the stack is empty.

<code>AND</code>, <code>OR</code>, <code>XOR</code> will remove the top two stack items and push the boolean and, or, xor of the two values onto the stack, respectively. For example, if the values are 0xdead (0b1101111010101101) and 0xbeef (0b1011111011101111):
 *<code>AND</code>will return 0x9ead (0b1001111010101101),
 *<code>OR</code>will return 0xfeef (0b1111111011101111),
 *<code>XOR</code>will return 0x6042 (0b0110000001000010).
 The script will fail if the stack has less then two items or the size of the top two items are not the same.

 <code>LSHIFT</code> will remove the top two stack items. The x<sub>2</sub>, interpreted as a little-endian string, will be left-shifted by x<sub>1</sub> bits and the result (with any trailing zero byte removed) is pushed onto the stack. For example, if x<sub>2</sub> is 0xbeef00 (0b101111101110111100000000) and x<sub>1</sub> is 11, the result is 0x00f07d07 (0b00000000111100000111110100000111). The script will fail if the stack has less then two items, or x<sub>1</sub> is negative, or size of the result (before removal of trailing zero) is larger than TBD bytes.

<code>RSHIFT</code> will remove the top two stack items. The x<sub>2</sub>, interpreted as a little-endian string, will be right-shifted by x<sub>1</sub> bits and the result (with any trailing zero byte removed) is pushed onto the stack. For example, if x<sub>2</sub> is 0xbeef00 (0b101111101110111100000000) and x<sub>1</sub> is 11, the result is 0x1d (0b00011101). The script will fail if the stack has less then two items or x<sub>1</sub> is negative.

<code>RESIZE</code> will remove the top two stack items. The x<sub>2</sub> will be resized to x<sub>1</sub> bytes and pushed onto the stack. Zero-padding or truncation will be made at the right hand side. For example, if x<sub>2</sub> is 0xdeadbeef, x<sub>1</sub> = 6 will return 0xdeadbeef0000, x<sub>1</sub> = 4 will return 0xdeadbeef, x<sub>1</sub> = 2 will return 0xdead, and x<sub>1</sub> = 0 will return a null string. The script will fail if the stack has less than two items, or x<sub>1</sub> is negative, or x<sub>1</sub> is greater than TBD.

<code>DUPTOALTSTACK</code> will copy the top main stack item onto the top of the alt stack. The main stack is not modified.

<code>DUPFROMALTSTACK</code> will copy the top alt stack item onto the top of the main stack. The alt stack is not modified.

<code>SWAPSTACK</code> will swap main stack and alt stack.

<code>EXPAND1</code> to <code>EXPAND32</code>, when executed, will remove all items in the stack and leave a single TRUE value, terminate the script evaluation and return a success immediately. They are reserved for future softfork of new opcodes.

The following scripts will pass:

  EXPAND1 (the empty stack is replaced by a single TRUE value)
  0 EXPAND1 (the FALSE stack is replaced by a single TRUE value)
  1 2 EXPAND1 (the stack with superfluous items is replaced by a single TRUE value)
  EXPAND1 RETURN (the script passes before RETURN is executed)
  EXPAND1 VERIF (the script passes before VERIF is executed)
  0 IF RETURN ELSE EXPAND1 ENDIF (RETURN is in an unexecuted branch)

The following scripts will fail:

  RETURN EXPAND1 (script failed before EXPAND1 is executed)
  0 IF EXPAND1 ELSE RETURN ENDIF (EXPAND1 is in an unexecuted branch)
  0 IF VERIF ELSE EXPAND1 ENDIF (VERIF is executed even in an unexecuted branch)

== Examples ==

=== Signing with a pre-specified k value ===

 DUP <2> <R-length + 2> SUBSTR <0x02|R-length|R> EQUALVERIFY <X pubkey> CHECKSIGVERIFY <Bob pubkey> CHECKSIG


  SIZE <R-length + 1> ADD <0x30> SWAPCAT <0x02|R-length|R> CAT SWAPCAT <X pubkey> CHECKSIGVERIFY <Bob pubkey> CHECKSIG
  "24h" CHECKSEQUENCEVERIFY DROP <Alice key> CHECKSIG

  <Bob sig> <0x02|S-length|S|sighashtype>


  <Bob sig> <0x02|S-length|S|sighashtype>                                           SIZE
  <Bob sig> <0x02|S-length|S|sighashtype> <S-length + 3>                            <R-length + 1>
  <Bob sig> <0x02|S-length|S|sighashtype> <S-length + 3> <R-length + 1>             ADD
  <Bob sig> <0x02|S-length|S|sighashtype> <Total length>                            <0x03>
  <Bob sig> <0x02|S-length|S|sighashtype> <Total length> <0x03>                     SWAPCAT
  <Bob sig> <0x02|S-length|S|sighashtype> <0x03|Total length>                       <0x02|R-length|R>
  <Bob sig> <0x02|S-length|S|sighashtype> <0x03|Total length> <0x02|R-length|R>     CAT
  <Bob sig> <0x02|S-length|S|sighashtype> <0x03|Total length|0x02|R-length|R>       SWAPCAT
  <Bob sig> <0x03|Total length|0x02|R-length|R|0x02|S-length|S|sighashtype>         <X pubkey>
  <Bob sig> <X sig> <X pubkey>                                                      CHECKSIGVERIFY
  <Bob sig>                                                                         <Bob pubkey>
  <Bob sig> <Bob pubkey>                                                            CHECKSIG
  <1>




=== Betting ===

  HASH160 <Secret-A hash 160> EQUALVERIFY <Pubkey-A> CHECKSIG
  "24h" CHECKSEQUENCEVERIFY DROP <Pubkey-B> CHECKSIG

  HASH160 <Secret-B hash 160> EQUALVERIFY <Pubkey-B> CHECKSIG
  "24h" CHECKSEQUENCEVERIFY DROP <Pubkey-A> CHECKSIG

  DUP HASH160 <Secret-B hash 160> EQUALVERIFY DUP HASH160 <Secret-A hash 160> EQUALVERIFY HASH256 SWAP HASH256 XOR <255> RSHIFT VERIFY <Pubkey-A> CHECKSIG
  DUP HASH160 <Secret-B hash 160> EQUALVERIFY DUP HASH160 <Secret-A hash 160> EQUALVERIFY HASH256 SWAP HASH256 XOR <255> RSHIFT NOT VERIFY <Pubkey-B> CHECKSIG
  <Pubkey-B> CHECKSIGVERIFY <Pubkey-A> CHECKSIG

  <Sig-B> <Secret-A> <Secret-B>


== Backward compatibility ==
As a soft fork, older software will continue to operate without modification. Non-upgraded nodes, however, will consider MAST programs as anyone-can-spend scripts. Wallets should always be wary of anyone-can-spend scripts and treat them with suspicion.

== Deployment ==
This BIP depends on [[bip-0141.mediawiki|BIP141]] and will be deployed by version-bits [[bip-0009.mediawiki|BIP9]] after BIP141 is enforced. Exact details TBD.

== Credits ==
The idea of MAST originates from Russell O’Connor, Pieter Wuille, and [https://bitcointalk.org/index.php?topic=255145.msg2757327#msg2757327 Peter Todd].

== Reference Implementation ==


== References ==


== Copyright ==
This document is placed in the public domain.
